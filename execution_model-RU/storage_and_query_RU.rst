.. _storage_and_query:

************************************************** **********
Хранение и запрос
************************************************** **********

Обзор
----------------------------------------

Сетевой уровень Хранение и запрос *отображается* каждому узлу в виде локальной, асинхронно доступной базы данных с арендованным хранилищем. Тем не менее, скрытно уровень хранилища и запроса полностью децентрализован и подчиняется согласованному алгоритму. В соответствии с возможностями микро транзакций, присущими решениям blockchain, пользователи dApp на RChain платят за ресурсы (вычислить, память, память и сеть), используя токены. Конструкция RChain считает, что все хранилища «сохранены», хотя не все данные будут сохранены навсегда. Вместо этого хранилище данных будет сдано в аренду и будет стоить производителям этих данных пропорционально его размеру, сложности и продолжительности аренды. Потребителям также может потребоваться оплатить доступ к поиску. Производители и потребители данных опосредованно платят операторам узлов.

Простая экономическая причина, оправдывающая лизинг, заключается в том, что хранение должно быть оплачено кем-то; иначе он не может быть надежно сохранен или «вечно». Мы решили сделать экономический механизм прямым. Экологически недружественная идея заключается в том, что хранение становится «бесплатным» только для субсидирования его несвязанным процессом. Малая часть реальной стоимости измерима в сигнатурах тепла центров обработки данных, которые растут до ошеломляющего размера. Эта зарядка для данных по мере их доступа также помогает уменьшить «атакующее» хранилище, а также хранение незаконного контента для дискредитации технологии.

Поддерживается множество данных, включая общедоступные незашифрованные json, зашифрованные BLOB или микс. Эти данные также могут быть простыми указателями или хешами контента, ссылающимися на внеплатформенные данные, хранящиеся в частных, публичных или консорциусных местоположениях и форматах.

Семантика данных
----------------------------------------

Блок-схема RChain будет хранить состояние, локальную историю транзакций и связанные с ним продолжения контракта. Как и Ethereum, блок-схема RChain также реализует криптоэкономически поддающуюся проверке транзакционную семантику для создания линейной временной истории вычислений, выполняемой на платформе. Обратите внимание, что математика, лежащая в основе этой семантической структуры цепочки, называется Traced Monoidal Category. Более подробно см.  `Recursion from Cyclic Sharing:Traced Monoidal Categories and Models of Cyclic Lambda Calculi`_.

.. _Recursion from Cyclic Sharing: отслеживаемые моноидальные категории и модели циклических вычислений лямбда: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.52.31&rep=rep1&type=pdf

============================================
Уровень доступа к данным и доменный язык
============================================

SpecialK - DSL для доступа к данным, а KVDB - структура данных распределенной памяти за DSL. SpecialK определяет распределенные шаблоны доступа к данным согласованным образом, как показано ниже:

.. table:: Figure - SpecialK’s Data Access Patterns

+---------------------------+-----------------------------------------------------+-----------------------------+-----------------------------------+--------------------------------------+
|                           | **Уровень чтения и написания (дистрибутивный замок)** | **Чтение и запись **        | **Публикация/Подпись сообщения** | **Публикация/ С историей** |
+===========================+=====================================================+=============================+===================================+======================================+
| **Дата**                  | Эфимерный                                           | Постоянный                  | Эфимерный                         | Постоянный                           |
+---------------------------+-----------------------------------------------------+-----------------------------+-----------------------------------+--------------------------------------+
| **Континиум(K)** [#]_     | Эфимерный                                            | Эфимерный                   | Persistent                        | Постоянный                           |
+---------------------------+-----------------------------------------------------+-----------------------------+-----------------------------------+--------------------------------------+
| **Повелетильный глагол** [#]_    | Put                                                 | Store                       | Publish                           | Publish with History                 |
+---------------------------+-----------------------------------------------------+-----------------------------+-----------------------------------+--------------------------------------+
| **Потребительский глагол**         | Get                                                 | Read                        | Subscribe                         | Subscribe                            |
+---------------------------+-----------------------------------------------------+-----------------------------+-----------------------------------+--------------------------------------+


* Рисунок - Шаблоны доступа к данным SpecialK *

С точки зрения SpecialK DSL и API, когда он выполняет действие по доступу к данным, такое как глагол Get (с шаблоном), безразлично, хранятся ли эти данные локально или удаленно, т.е. в какой-либо другой сети узел. Существует единственный механизм запроса независимо.

Технологический стек 2016 года и предшествующий SpecialK (Agent Services, SpecialK и KVDB с RabbitMQ и MongoDB) поставляли децентрализованную сеть доставки контента, хотя она не была ни измерена, ни монетизирована. Компоненты SpecialK & KVDB располагаются поверх MongoDB и расширенного протокола очереди сообщений (ZeroMQ изучается) для создания децентрализованной логики для хранения и извлечения контента как локально, так и удаленно. Текущие версии 1.0 SpecialK и KVDB написаны на Scala и находятся в `GitHub`_.

.. _GitHub: https://github.com/leithaus/SpecialK

Семантика запроса изменяется в зависимости от того, какой уровень в архитектуре задействован. На уровне SpecialK ключи представляют собой прологовые выражения, которые позже запрашиваются через выражения datalog. В архитектуре используются расширенные выражения меток, а для запроса используются выражения меток datalog. В RChain уровни SpecialK и KVDB будут повторно реализованы в Rholang (по сравнению с предыдущей реализацией в Scala с пользовательской реализацией разграниченных продолжений и сериализации кода).

Для получения дополнительной информации см.`SpecialK & KVDB`_ - язык шаблонов для Интернета.

.. _SpecialK & KVDB: https://docs.google.com/document/d/1aM5OIJWOyW89rHdUg6d9-YVbItdtxxiosP_fXZQaRdg/edit

================================================== ===
KVDB - доступ к данным и продолжению, кэш
================================================== ===

Доступ к данным будет осуществляться с помощью семантики SpecialK, в то время как физически хранится в децентрализованной базе данных Key-Value, известной как «KVDB». Ниже показано, как два узла взаимодействуют для ответа на запрос получения:


.. figure:: ../img/specialk.png
  :align: center
  :width: 3446
  :scale: 25
  
  * Рисунок - Децентрализованный доступ к данным в SpecialK *
  

1) Сначала узел запрашивает свой кеш в памяти для запрошенных данных. Тогда, если он не найден,

2) запрашивает его локальное хранилище и, если он не найден, сохраняет разграниченное продолжение в этом месте и

3) запрашивает сеть. Если и когда сеть вернет соответствующие данные, разграниченное продолжение вернется в область видимости с выбранными данными в качестве параметра.

Почему RChain не выбрал IPFS (межпланетную файловую систему) для распределенной памяти? В дополнение к рискам централизации IPFS использует путь для доступа к контенту, тогда как SpecialK использует целые деревья (и деревья с дырками в них) для доступа к контенту. IPFS имеет интуитивную модель пути, но этот дизайн задает вопрос о том, как выполнять запросы. SpecialK запускается со стороны запроса. Теперь проект RChain может извлечь выгоду из работы IPFS, включая их хеширование для адресации контента, как только семантика запроса SpecialK будет на месте. SpecialK также может использовать случайно сгенерированный плоский ключ, который не имеет корреляции с данными.

Связь P2P-узла
---------------------------------------------

Децентрализованная семантика хранилища SpecialK требует узловой инфраструктуры связи. Подобно другим децентрализованным реализациям, компонент связи P2P обрабатывает обнаружение узлов, доверие между узлами и связь. В текущей реализации используется RabbitMQ, хотя рассматривается ZeroMQ.

.. [#] Обратите внимание, что по соглашению функция продолжения представляется как параметр с именем k.
.. [#] Это только подмножество глаголов, доступных при этом разложении функциональности. Например, выбор из глагола получает данные, не оставляя продолжения вокруг, если данных нет.

